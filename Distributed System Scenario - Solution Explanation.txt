When implementing a mechanism like this there are a couple of challenges:
	1. Instances do not have access to each others memory so using memory or objects stored in memory is not an option.
	2. Creating UNIQUE CONSTRAINTS in db and handling the exceptions that could occur during transactions is not an option because we are not given any information about DB side and was asked to work only on the Service layer.
	3. Using RAW SQL queries to lock a resource is not an option per the reasons stated above.
	4. Rowlocking queries is not an option because I have to work only on Service Layer and the row is created only after the entire process is completed, changing that would also require modifying the Backend layer.

Keeping these in mind there are several possible approaches. All approaches must contain an external system that each server can access:
	
	1. Using a message queue system like Rabbit MQ or Kafka.
	2. Creating a new table that handles transactions, for an example it would have columns {TRANSACTION_ID, ItemContent, Status}, then a row would be created with the STATUS of 'IN PROCESS' before we start processing an item. We would also use this table before calling SaveItem function to make sure there are no items that have the same ItemContent and currently being processed. But this solution requires us to kind of write code that belongs to Backend layer inside Service layer, which is just not nice.
	3. Use an external caching system like Redis.

I will be using the third approach however there are some cons to using Redis:

	1. Not free.
	2. If it will be used on premises, it would need to be configured first.
	3. If it will be used as a cloud solution, we need to make sure it complies with company data security procedures.
	4. Since it is an external system, network quality is very important. Instabilities in that might result in two instances of the application thinking they have a lock over the same object.
	5. Any cybersecurity measure that was taken for other computing systems will also have to be taken for the Redis server.

However it is also a lightweight, easy to implement solution and the cons can be mitigated with clustering.